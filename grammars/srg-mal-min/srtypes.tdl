
clause := phrasal &
  [ SYNSEM.LOCAL.CAT [ HEAD +vc ] ].


non-rel-phrase := head-nexus-rel-phrase & 
  [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
                               INDEX #ind ],
             NON-LOCAL.REL 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #ind,
                      NON-LOCAL.REL 0-dlist ],
    C-CONT.HOOK [ LTOP #ltop,
                  INDEX #ind ] ].

basic-non-rel-clause := non-rel-phrase & clause.

non-rel-clause := basic-non-rel-clause.

declarative-clause := non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


phrasal := phrase &
  [ SYNSEM phr-synsem ]
""" Most but not all phrases have SYNSEM phr-synsem
""".

very-basic-binary-phrase := phrase &
  [ ARGS < sign, sign >,
    NON-HEAD-DTR sign ].

basic-binary-phrase := very-basic-binary-phrase & 
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
                        HCONS [ LIST #scfirst,
                                LAST #sclast ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle1 ],
             HCONS [ LIST #scfirst,
                     LAST #scmiddle1 ] ],
    ARGS < [ SYNSEM.LOCAL local &
                          [ CONT [ RELS [ LIST #middle1,
                                          LAST #middle2 ],
                                   HCONS [ LIST #scmiddle1,
                                           LAST #scmiddle2 ] ] ] ],
           [ SYNSEM.LOCAL local &
                          [ CONT [ RELS [ LIST #middle2,
                                          LAST #last ],
                                   HCONS [ LIST #scmiddle2,
                                           LAST #sclast ] ] ] ] > ].


binary-phrase := basic-binary-phrase &
  [ INFLECTED +,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct ],
    ARGS < [ INFLECTED +,
             SYNSEM.PUNCT.LPUNCT #lpunct  ],
           [ INFLECTED +, 
             SYNSEM.PUNCT.RPUNCT #rpunct ] > ].

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase.

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
                        HCONS [ LIST #scfirst,
                                LAST #sclast ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle ],
             HCONS [ LIST #scfirst,
                     LAST #scmiddle ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
                                 [ CONT [ RELS [ LIST #middle,
                                                 LAST #last ],
                                          HCONS [ LIST #scmiddle,
                                                  LAST #sclast ] ] ] ] > ].

norm-unary-phrase := basic-unary-phrase &
  [ SYNSEM.PUNCT #punct,
    ARGS < [ SYNSEM.PUNCT #punct ] > ].

unary-phrase := norm-unary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ] > ].


head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ]
"""
; C-CONT is the semantic contribution of the phrase itself. The hook of the phrase is 
; identified with the hook of C-CONT (which is possibly but not necessarily identified 
; with the hook of one of the daughters. The rels and hcons of the phrase result from 
; appending the rels and hcons of C-CONT and the rels and hcons of the daughters.
; Head-compositional phrases identify the syntactic head daughter as the semantic head.
""".

head-only := unary-phrase & headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED solely,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING solely ],
    ARGS < #head > ].

non-clause := head-nexus-phrase &
  [ SYNSEM.LOCAL.CAT.MC na ].


basic-headed-phrase := phrase & 
  [ SYNSEM.LOCAL [ COORD #coord,
                   COORD-STRAT #coord-strat,
                   CAT.HEAD head ],
    HEAD-DTR.SYNSEM.LOCAL local & [ COORD #coord & -,
                                    COORD-STRAT #coord-strat ] ].

headed-phrase := basic-headed-phrase & 
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT.HEAD #head ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD #head,
                            CONT.HOOK.INDEX #agr ] ].


head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ]
"""
; head/nexus phrases pass up the REL and QUE values of the head daughter, 
; which has amalgamated the REL and QUE values of its arguments to the mother
""".


head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ]
"""
; In a head/local dependent phrase, the SLASH feature of the mother is token-identical 
; to that of the head daughter, which has already amalgamated the SLASH values of its arguments. 
""".

basic-head-comp-phrase := basic-head-comp-or-marker-phrase & 
  [ SYNSEM [ LOCAL.CAT [ POSTHEAD #ph,
                         VAL.COMPS #comps ],
             LIGHT - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                                HEAD.KEYS.KEY independent_rel,
                                VAL.COMPS < #synsem . #comps > ],
    NON-HEAD-DTR.SYNSEM canonical-synsem & #synsem,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].



optsp_constr := optspec_phrase & rule.

head-comp_x-xp_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD #slshd,
    HEAD-DTR.SYNSEM.SLSHD #slshd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].


hd-cmp_x-xp_constr := head-comp_x-xp_phrase & binary-rule-right-to-left. ; ***

basic-head-comp-or-marker-phrase := head-valence-phrase & head-compositional & binary-headed-phrase &
  [ SYNSEM canonical-synsem &
           [ LOCAL.CAT [ MC #mc,
                         VAL [ SUBJ #subj,
                               SPR #spr,
                               SPEC #spec,
                               CLTS #clts ] ],
             MODIFIED #modif ],
    HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                              CAT [ HEAD +nvjrpc, 
                                    MC #mc,
                                    VAL [ SUBJ #subj,
                                          SPR #spr,
                                          SPEC #spec,
                                          CLTS #clts ] ] ],
                      MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM canonical-synsem  ].

binary-rule-left-to-right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ]
"""
; For more efficient parsing, designate one argument or the other
; as the KEY-ARG: that which should be unified with first.
""".


binary-rule-right-to-left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-comp_x-xp_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD #slshd,
    HEAD-DTR.SYNSEM.SLSHD #slshd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].

head-initial := binary-headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED left,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING left ],
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].


head-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.STR.HEADED left ].


optspec_phrase := head-valence-phrase & non-clause & head-only & head-compositional & 
  [ INFLECTED #infl,
    SYNSEM [ MODIFIED #mod,
             LIGHT -,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #cstrat,
                     AGR #agr,
                     CAT [ MC #mc,
                           POSTHEAD #ph,
                           VAL [ SPR < >,
                                 SUBJ #subj,
                                 COMPS #comps,
                                 SPEC #spec ] ] ] ],
    HEAD-DTR [ INFLECTED #infl & +,
               SYNSEM [ MODIFIED #mod,
                        SLSHD #slshd,
                        LOCAL [ COORD #coord & -,
                                COORD-STRAT #cstrat & zero,
                                AGR #agr,
                                CAT [ MC #mc,
                                      POSTHEAD #ph, 
                                      HEAD noun,
                                      VAL [ SPR < [ OPT +, 
                                                    NON-LOCAL [ SLASH 0-dlist,
                                                                REL 0-dlist,
                                                                QUE 0-dlist ] ] >,
                                            SUBJ #subj,
                                            COMPS #comps & < >,
                                            SPEC #spec ] ] ] ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ]
"""
; -- optional specifier
""".

sp-hd-mal-m-f_constr := spec-head-mal-m-f-phrase & binary-rule-left-to-right. ; ***

spec-head_phrase := norm_spec-head-phrase & binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD #head & 
                              [ CASE #case, 
                                KEYS #keys,
                                LEARNER - ],
                         VAL.SPR #spr ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ AGR.PNG.GEN #gen,
                              CAT [ HEAD #head &
                                         [ CASE #case, 
                                           KEYS #keys ],
                                    VAL [ SPR < #synsem . #spr >,
                                          COMPS < > ] ] ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM #synsem & 
                        [ LOCAL [ AGR.PNG.GEN #gen,
                                  CAT [ HEAD det & [ KEYS.KEY quant_or_wh_rel ],
                                        VAL.SPEC < [ LOCAL.CAT.HEAD #head ] > ],
                                  CONT.HOOK #hook ] ],
    C-CONT.HOOK #hook ]
"""
; for specifiers of nouns
; OZ: I think the hook is already identified in the basic phrase?
""".

spec-head-mal-m-f-phrase := norm_spec-head-mal-phrase & binary-headed-phrase & 
  [ SYNSEM.LOCAL [  AGR.PNG.GEN fem,
                    CAT [ HEAD #head & 
                              [ CASE #case, 
                                KEYS #keys,
                                LEARNER + ],
                         VAL.SPR #spr ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ AGR.PNG.GEN fem,
                              CAT [ HEAD #head &
                                         [ CASE #case, 
                                           KEYS #keys ],
                                    VAL [ SPR < #synsem . #spr >,
                                          COMPS < > ] ] ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM #synsem & 
                        [ LOCAL [ AGR.PNG.GEN masc,
                                  CAT [ HEAD det & [ KEYS.KEY quant_or_wh_rel ],
                                        VAL.SPEC < [ LOCAL.CAT.HEAD #head ] > ] ] ] ]
"""
; for learner constructions where specifier is masculine and the noun feminine.
; 
""".

norm_spec-head-phrase := norm-basic-head-spec-phrase & 
  [ SYNSEM.LOCAL.STR.HEADED right,
    NON-HEAD-DTR #non-head-dtr &
                 [ SYNSEM [ PUNCT.RPUNCT no_punct,
                            LOCAL.CAT.POSTHEAD - ] ],
    HEAD-DTR #head-dtr & [ SYNSEM.LOCAL.STR.HEADING right ],
    ARGS < #non-head-dtr, #head-dtr > ].

norm_spec-head-mal-phrase := norm-basic-head-spec-mal-phrase & 
  [ SYNSEM.LOCAL.STR.HEADED right,
    NON-HEAD-DTR #non-head-dtr &
                 [ SYNSEM [ PUNCT.RPUNCT no_punct,
                            LOCAL.CAT.POSTHEAD - ] ],
    HEAD-DTR #head-dtr & [ SYNSEM.LOCAL.STR.HEADING right ],
    ARGS < #non-head-dtr, #head-dtr > ].

    norm-basic-head-spec-phrase := basic-head-spec-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD #mod,
                            PRD #prd,
                            TAM #tam,
                            KEYS.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MOD #mod,
                                       PRD #prd,
                                       TAM #tam,
                                       KEYS.KEY #key ],
                                VAL.SPR < #synsem > ],
    NON-HEAD-DTR.SYNSEM #synsem ].
    
norm-basic-head-spec-mal-phrase := basic-head-spec-mal-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD #mod,
                            PRD #prd,
                            TAM #tam,
                            KEYS.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MOD #mod,
                                       PRD #prd,
                                       TAM #tam,
                                       KEYS.KEY #key ],
                                VAL.SPR < #synsem > ],
    NON-HEAD-DTR.SYNSEM #synsem ].

basic-head-spec-phrase := head-valence-phrase & phrasal & very-basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD -,
                     COORD-STRAT #coord-strat,
                     AGR #agr,
                     CAT [ MC #mc,
                           POSTHEAD #hdph,
                           VAL [ SUBJ #subj,
                                 COMPS #spcomps,
                                 SPEC #spec,
                                 CLTS #clit ] ] ],
             MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ SLSHD #slshd,
                        LOCAL [ COORD -,
                                COORD-STRAT #coord-strat,
                                CAT [ MC #mc,
                                      POSTHEAD #hdph,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps & < >,
                                            SPEC #spec,
                                            CLTS #clit & < > ] ],
                                CONT.HOOK #hdhook & [ INDEX #agr ] ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                                  CAT [ VAL [ SPEC < [ LOCAL [ CAT.VAL.COMPS #comps,
                                                               CONT.HOOK #hdhook ],
                                                       MODIFIED #hmodif ] >,
                                              COMPS #spcomps ] ] ],
                          MODIFIED #modif ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ]
"""
; agreement features are percolated from HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX 
; where NUMBER is not checked in 'ad sensum agreement'
""".

basic-head-spec-mal-phrase := head-valence-phrase & phrasal & very-basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD -,
                     COORD-STRAT #coord-strat,
                     AGR #agr,
                     CAT [ MC #mc,
                           POSTHEAD #hdph,
                           VAL [ SUBJ #subj,
                                 COMPS #spcomps,
                                 SPEC #spec,
                                 CLTS #clit ] ] ],
             MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ SLSHD #slshd,
                        LOCAL [ COORD -,
                                COORD-STRAT #coord-strat,
                                CAT [ MC #mc,
                                      POSTHEAD #hdph,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps & < >,
                                            SPEC #spec,
                                            CLTS #clit & < > ] ],
                                CONT.HOOK [ LTOP #ltop, XARG #xarg, INDEX #agr & [ PNG.PN #pernum, DEF #def, PRONTYPE #prontype ] ] ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                                  CAT [ VAL [ SPEC < [ LOCAL [ CAT.VAL.COMPS #comps,
                                                               CONT.HOOK [ INDEX [ PRONTYPE #prontype, DEF #def, PNG.PN #pernum ], LTOP #ltop, XARG #xarg ] ],
                                                       MODIFIED #hmodif ] >,
                                              COMPS #spcomps ] ] ],
                          MODIFIED #modif ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ]
"""
; The gender is underspecified here, to be later specified with a number of mal-rules.
""".

sp-hd_constr := spec-head_phrase & binary-rule-left-to-right. ; ***


sbj-hd_constr := subj-head_nonque_phrase & declarative-clause & binary-rule-right-to-left. ; ***


subj-head_nonque_phrase := subj-head-phrase &
  [ HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ].


norm-basic-head-subj-phrase := basic-head-subj-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #synsem >,
    NON-HEAD-DTR.SYNSEM #synsem ].


subj-head-phrase := norm-basic-head-subj-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL.COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & 
                                     [ INV -, 
                                       VFORM fin ],
                                VAL.COMPS olist ] ]
"""
; In languages which do realize all COMPS before the SUBJ, head-subj-phrase should allow [COMPS olist]
""".

basic-head-final := basic-binary-headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED right,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING right ],
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.


basic-head-subj-phrase := head-valence-phrase & head-compositional & binary-headed-phrase &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL.CAT [ MC #mc,
                       VAL [ COMPS #comps,
                             SPR #spr,
                             SPEC #spec,
                             CLTS #clit ] ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD -,
                            CAT [ MC #mc,
                                  HEAD.KEYS.KEY v_event_rel, 
                                  VAL [ COMPS #comps,       
                                        SPR #spr,
                                        SPEC #spec,
                                        CLTS #clit & < > ] ] ] ],
    NON-HEAD-DTR.SYNSEM canonical-synsem &
                        [ NON-LOCAL.REL 0-dlist ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


hd-pt_constr := head-punct_phrase & binary-rule-right-to-left.

head-punct_phrase := basic-head-punct-phrase & basic-binary-phrase &
  [ SYNSEM [ LIGHT +,
             LOCAL.STR.HEADED left,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ] ],
    HEAD-DTR #head & 
             [ SYNSEM [ LIGHT +,
                        PUNCT.LPUNCT #lpunct & no_punct,
                        LOCAL.STR.HEADING left ] ],
    NON-HEAD-DTR #non-head & 
                 [ SYNSEM punct_synsem & 
                          [ LOCAL.CAT.HEAD.PUNCT-MK #rpunct & rpunct ] ],
    ARGS < #head, #non-head > ].
    
basic-head-punct-phrase := head-valence-phrase & head-compositional &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     CAT #cat,
                     CONT #cont ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              STR.HEADED solely,
                              CAT #cat,
                              CONT #cont ] ] ].


